(!******************************************************
   Maximum Covering Location Problem (MCLP)
   Local Search with Delta-Evaluation

   Algorithm: Iterative improvement using 1-flip and swap
   neighborhoods. Delta-evaluation provides efficient
   incremental objective computation.

   Neighborhoods:
   1. 1-flip: Open or close a single facility
   2. Swap: Close one facility, open another

   Strategy: First-improvement (accept first improving move)

   Time Complexity: O(max_moves · nI · nJ) per run
   Space Complexity: O(nI + nJ)

   Reference: Classic local search for facility location

   Author: Syed Abbas Ahmad
   Date: November 2025
   Phase: 4 - Multi-Start Local Search
******************************************************!)

model "MCLP_LocalSearch"
  uses "mmsystem"

  !==================================================
  ! PARAMETERS
  !==================================================

  parameters
    DATA_FILE = "data/test_tiny.dat"  ! Default instance
    INIT_METHOD = "greedy"             ! Initialization: greedy, cn, random
    MAX_MOVES = 200                    ! Maximum improvement iterations
    SEED = 42                          ! Random seed
  end-parameters

  !==================================================
  ! FORWARD DECLARATIONS
  !==================================================

  declarations
    nI, nJ: integer
    BUDGET: real
  end-declarations

  !==================================================
  ! LOAD INSTANCE DIMENSIONS
  !==================================================

  initializations from DATA_FILE
    nI nJ BUDGET
  end-initializations

  declarations
    ! Additional variables
    covered: set of integer
    best_fac: integer
    best_ratio: real
    new_cust: set of integer
    ratio: real
    fac_list: array(1..nI) of integer
    temp: integer
    fac: integer
    loss: real
    swap_idx: integer
    idx: integer
    gain: real
    start_time: real
    iteration: integer
    improvements: integer
    best_move_type: string
    delta: real
    best_i: integer
    best_j: integer
    found_improvement: boolean
    recomputed_obj: real
  end-declarations

    writeln("\n", "======================================================================")
    writeln("MCLP LOCAL SEARCH")
    writeln("======================================================================")
    writeln("Instance: ", DATA_FILE)
    writeln("Facilities: ", nI, ", Customers: ", nJ)
    writeln("Budget: ", BUDGET)
    writeln("Initialization: ", INIT_METHOD)
    writeln("======================================================================", "\n")

  !==================================================
  ! MAIN DECLARATIONS
  !==================================================

  declarations
    FACILITIES: set of integer
    CUSTOMERS: set of integer
    COST: array(0..nI-1) of real
    DEMAND: array(0..nJ-1) of real
    I_j: array(0..nJ-1) of set of integer
    J_i: array(0..nI-1) of set of integer
    total_demand: real
  end-declarations

  !==================================================
  ! LOAD INSTANCE DATA
  !==================================================

  initializations from DATA_FILE
    FACILITIES CUSTOMERS
    COST DEMAND
    I_j as "COVERAGE_I_j"
    J_i as "COVERAGE_J_i"
  end-initializations

  total_demand := sum(j in CUSTOMERS) DEMAND(j)

  !==================================================
  ! INITIALIZATION
  !==================================================

  declarations
    K: set of integer                  ! Open facilities (current solution)
    covered_by_count: array(0..nJ-1) of integer  ! Coverage count per customer
    budget_used: real
    objective: real
  end-declarations

  ! Initialize based on method
  if INIT_METHOD = "greedy" then
      writeln("Initializing with Greedy heuristic...")

    ! Run Greedy algorithm (inline simplified version)
    K := {}
    covered := {}
    budget_used := 0.0

    while (budget_used < BUDGET) do
      best_fac := -1
      best_ratio := 0.0

      forall(i in FACILITIES) do
        if i in K or budget_used + COST(i) > BUDGET then
          next
        end-if

        new_cust := J_i(i) - covered
        gain := sum(j in new_cust) DEMAND(j)
        ratio := gain / COST(i)

        if ratio > best_ratio then
          best_ratio := ratio
          best_fac := i
        end-if
      end-do

      if best_fac = -1 or best_ratio <= 0 then
        break
      end-if

      K += {best_fac}
      covered += J_i(best_fac)
      budget_used += COST(best_fac)
    end-do

  elif INIT_METHOD = "random" then
      writeln("Initializing with random solution...")

    ! Random initialization
    K := {}
    budget_used := 0.0
    idx := 1
    forall(i in FACILITIES) do
      fac_list(idx) := i
      idx += 1
    end-do

    ! Shuffle using seed
    setrandseed(SEED)
    forall(i in 1..nI) do
      swap_idx := ceil(random * (nI - i + 1)) + i - 1
      if swap_idx >= i then
        temp := fac_list(i)
        fac_list(i) := fac_list(swap_idx)
        fac_list(swap_idx) := temp
      end-if
    end-do

    forall(i in 1..nI) do
      fac := fac_list(i)
      if budget_used + COST(fac) <= BUDGET then
        K += {fac}
        budget_used += COST(fac)
      end-if
    end-do
  else
    ! Default: empty solution (will be filled by local search)
    K := {}
    budget_used := 0.0
  end-if

  ! Initialize coverage tracking
  forall(j in CUSTOMERS)
    covered_by_count(j) := 0

  forall(i in K) do
    forall(j in J_i(i))
      covered_by_count(j) += 1
  end-do

  ! Compute initial objective
  objective := 0.0
  forall(j in CUSTOMERS) do
    if covered_by_count(j) > 0 then
      objective += DEMAND(j)
    end-if
  end-do

  budget_used := sum(i in K) COST(i)

    writeln("Initial Solution:")
    writeln("  Open facilities: ", getsize(K))
    writeln("  Objective: ", strfmt(objective, 10, 2))
    writeln("  Budget used: ", strfmt(budget_used, 10, 2), " / ", BUDGET)
    writeln("")

  !==================================================
  ! LOCAL SEARCH - DELTA EVALUATION FUNCTIONS
  !==================================================

  ! Delta evaluation for closing facility i
  function delta_close(i: integer): real
    if i not in K then
      returned := -999999.0
    else
      loss := 0.0
      forall(j in J_i(i)) do
        if covered_by_count(j) = 1 then
          loss += DEMAND(j)
        end-if
      end-do
      returned := -loss
    end-if
  end-function

  ! Delta evaluation for opening facility i
  function delta_open(i: integer): real
    if i in K then
      returned := -999999.0
    elif budget_used + COST(i) > BUDGET then
      returned := -999999.0
    else
      gain := 0.0
      forall(j in J_i(i)) do
        if covered_by_count(j) = 0 then
          gain += DEMAND(j)
        end-if
      end-do
      returned := gain
    end-if
  end-function

  ! Delta evaluation for swap: close i_out, open j_in
  function delta_swap(i_out: integer, j_in: integer): real
    if i_out not in K or j_in in K then
      returned := -999999.0
    elif budget_used - COST(i_out) + COST(j_in) > BUDGET then
      returned := -999999.0
    else
      ! Loss from closing i_out
      loss := 0.0
      forall(j in J_i(i_out)) do
        if covered_by_count(j) = 1 then
          loss += DEMAND(j)
        end-if
      end-do

      ! Gain from opening j_in
      gain := 0.0
      forall(j in J_i(j_in)) do
        if covered_by_count(j) = 0 then
          gain += DEMAND(j)
        elif covered_by_count(j) = 1 and i_out in I_j(j) then
          ! j was only covered by i_out, now will be covered by j_in
          gain += DEMAND(j)
        end-if
      end-do

      returned := gain - loss
    end-if
  end-function

  ! Apply close move
  procedure apply_close(i: integer)
    if i not in K then
      return
    end-if

    K -= {i}
    budget_used -= COST(i)

    forall(j in J_i(i)) do
      covered_by_count(j) -= 1
      if covered_by_count(j) = 0 then
        objective -= DEMAND(j)
      end-if
    end-do
  end-procedure

  ! Apply open move
  procedure apply_open(i: integer)
    if i in K then
      return
    end-if

    K += {i}
    budget_used += COST(i)

    forall(j in J_i(i)) do
      if covered_by_count(j) = 0 then
        objective += DEMAND(j)
      end-if
      covered_by_count(j) += 1
    end-do
  end-procedure

  ! Apply swap move
  procedure apply_swap(i_out: integer, j_in: integer)
    apply_close(i_out)
    apply_open(j_in)
  end-procedure

  !==================================================
  ! LOCAL SEARCH - MAIN LOOP
  !==================================================

  start_time := gettime
  iteration := 0
  improvements := 0

    writeln("Starting Local Search...")
    writeln("----------------------------------------------------------------------")

  while (iteration < MAX_MOVES) do
    iteration += 1

    ! Find best improving move (first-improvement strategy)
    best_move_type := ""
    best_delta := 0.0
    best_i := -1
    best_j := -1
    found_improvement := false

    ! Try 1-flip: Close moves
    forall(i in K) do
      delta := delta_close(i)
      if delta > best_delta then
        best_delta := delta
        best_move_type := "close"
        best_i := i
        found_improvement := true
        break  ! First-improvement: take first improving move
      end-if
    end-do

    ! Try 1-flip: Open moves (if no close improvement found)
    if not found_improvement then
      forall(i in FACILITIES | i not in K) do
        delta := delta_open(i)
        if delta > best_delta then
          best_delta := delta
          best_move_type := "open"
          best_i := i
          found_improvement := true
          break
        end-if
      end-do
    end-if

    ! Try Swap moves (if no 1-flip improvement found)
    if not found_improvement then
      forall(i_out in K) do
        forall(j_in in FACILITIES | j_in not in K) do
          delta := delta_swap(i_out, j_in)
          if delta > best_delta then
            best_delta := delta
            best_move_type := "swap"
            best_i := i_out
            best_j := j_in
            found_improvement := true
            break  ! First-improvement
          end-if
        end-do
        if found_improvement then
          break
        end-if
      end-do
    end-if

    ! If no improving move found, terminate
    if not found_improvement or best_delta <= 1e-6 then
      break
    end-if

    ! Apply best move
    if best_move_type = "close" then
      apply_close(best_i)
      improvements += 1
    elif best_move_type = "open" then
      apply_open(best_i)
      improvements += 1
    elif best_move_type = "swap" then
      apply_swap(best_i, best_j)
      improvements += 1
    end-if
  end-do

  solve_time := gettime - start_time

  !==================================================
  ! OUTPUT RESULTS
  !==================================================

  num_open := getsize(K)
  num_covered := sum(j in CUSTOMERS) if(covered_by_count(j) > 0, 1, 0)
  coverage_pct := num_covered / nJ * 100
  demand_pct := objective / total_demand * 100
  budget_pct := budget_used / BUDGET * 100

    writeln("----------------------------------------------------------------------")
    writeln("\nLOCAL SEARCH SOLUTION:")
    writeln("  Iterations: ", iteration)
    writeln("  Improvements: ", improvements)
    writeln("  Open facilities: ", num_open, " / ", nI)
    writeln("  Covered customers: ", num_covered, " / ", nJ,
            " (", strfmt(coverage_pct, 5, 1), "%)")
    writeln("  Budget used: ", strfmt(budget_used, 10, 2),
            " / ", strfmt(BUDGET, 10, 2),
            " (", strfmt(budget_pct, 5, 1), "%)")
    writeln("  Final objective: ", strfmt(objective, 10, 2),
            " / ", strfmt(total_demand, 10, 2),
            " (", strfmt(demand_pct, 5, 1), "%)")
    writeln("  Runtime: ", strfmt(solve_time, 8, 4), " seconds")

    writeln("\nOPEN FACILITIES:")
    write(" ")
    forall(i in K)
      write(" ", i)
    writeln("")

  writeln("\n", "======================================================================")

  !==================================================
  ! SOLUTION VALIDATION
  !==================================================


end-model
