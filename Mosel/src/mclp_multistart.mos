(!******************************************************
   Maximum Covering Location Problem (MCLP)
   Multi-Start Local Search

   Algorithm: Run local search from multiple diverse
   initial solutions and track the global best.

   Initialization Strategies:
   1. Deterministic Greedy
   2. Deterministic Closest Neighbor
   3. Perturbed Greedy (randomized)
   4. Random solutions

   Time Complexity: O(n_starts · max_moves · nI · nJ)
   Space Complexity: O(nI + nJ)

   Reference: Multi-start metaheuristic framework

   Author: MCLP Migration Team
   Date: November 2025
   Phase: 4 - Multi-Start Local Search
******************************************************!)

model "MCLP_Multi_Start"

  !==================================================
  ! PARAMETERS
  !==================================================

  parameters
    DATA_FILE = "data/test_tiny.dat"  ! Default instance
    N_STARTS = 10                      ! Number of starts
    MAX_MOVES = 200                    ! LS iterations per start
    BASE_SEED = 42                     ! Base random seed
    VERBOSE = 1                        ! Output level (0=quiet, 1=normal, 2=detailed)
  end-parameters

  !==================================================
  ! FORWARD DECLARATIONS
  !==================================================

  declarations
    nI, nJ: integer
    BUDGET: real
  end-declarations

  !==================================================
  ! LOAD INSTANCE DIMENSIONS
  !==================================================

  initializations from DATA_FILE
    nI nJ BUDGET
  end-initializations

  if VERBOSE >= 1 then
    writeln("\n", "="*70)
    writeln("MCLP MULTI-START LOCAL SEARCH")
    writeln("="*70)
    writeln("Instance: ", DATA_FILE)
    writeln("Facilities: ", nI, ", Customers: ", nJ)
    writeln("Budget: ", BUDGET)
    writeln("Number of starts: ", N_STARTS)
    writeln("="*70, "\n")
  end-if

  !==================================================
  ! MAIN DECLARATIONS
  !==================================================

  declarations
    FACILITIES: set of integer
    CUSTOMERS: set of integer
    COST: array(0..nI-1) of real
    DEMAND: array(0..nJ-1) of real
    I_j: array(0..nJ-1) of set of integer
    J_i: array(0..nI-1) of set of integer
  end-declarations

  !==================================================
  ! LOAD INSTANCE DATA
  !==================================================

  initializations from DATA_FILE
    FACILITIES CUSTOMERS
    COST DEMAND
    I_j as "COVERAGE_I_j"
    J_i as "COVERAGE_J_i"
  end-initializations

  total_demand := sum(j in CUSTOMERS) DEMAND(j)

  if VERBOSE >= 1 then
    writeln("Instance Statistics:")
    writeln("  Total demand: ", strfmt(total_demand, 10, 2))
    writeln("  LS max moves per start: ", MAX_MOVES, "\n")
  end-if

  !==================================================
  ! MULTI-START TRACKING
  !==================================================

  declarations
    global_best_K: set of integer
    global_best_obj: real
    start_results: array(1..N_STARTS) of record
      start_idx: integer
      method: string
      initial_obj: real
      final_obj: real
      improvement: real
      num_moves: integer
      runtime: real
    end-record
  end-declarations

  global_best_K := {}
  global_best_obj := -infinity

  overall_start_time := gettime

  !==================================================
  ! MULTI-START LOOP
  !==================================================

  forall(start_idx in 1..N_STARTS) do
    seed := BASE_SEED + start_idx

    ! Determine initialization method
    if start_idx = 1 then
      init_method := "Greedy"
      use_greedy := true
      use_cn := false
      use_random := false
      perturb := false
    elif start_idx = 2 then
      init_method := "Closest-Neighbor"
      use_greedy := false
      use_cn := true
      use_random := false
      perturb := false
    elif start_idx <= (N_STARTS + 2) / 2 then
      init_method := "Perturbed-Greedy"
      use_greedy := true
      use_cn := false
      use_random := false
      perturb := true
    else
      init_method := "Random"
      use_greedy := false
      use_cn := false
      use_random := true
      perturb := false
    end-if

    if VERBOSE >= 1 then
      writeln("\n", "-"*70)
      writeln("Start ", start_idx, " / ", N_STARTS, " (", init_method, ")")
      writeln("-"*70)
    end-if

    start_time := gettime

    ! ================================================
    ! INITIALIZATION
    ! ================================================

    declarations
      K: set of integer
      covered_by_count: array(0..nJ-1) of integer
      budget_used: real
      objective: real
    end-declarations

    K := {}
    budget_used := 0.0

    ! Initialize based on method
    if use_greedy then
      ! Greedy initialization
      covered := {}

      while budget_used < BUDGET do
        best_fac := -1
        best_ratio := 0.0

        forall(i in FACILITIES) do
          if i in K or budget_used + COST(i) > BUDGET then
            next
          end-if

          new_cust := J_i(i) - covered
          gain := sum(j in new_cust) DEMAND(j)
          ratio := if(COST(i) > 0, gain / COST(i), 999999)

          if ratio > best_ratio then
            best_ratio := ratio
            best_fac := i
          end-if
        end-do

        if best_fac = -1 or best_ratio <= 0 then
          break
        end-if

        K += {best_fac}
        covered += J_i(best_fac)
        budget_used += COST(best_fac)
      end-do

      ! Perturbation for diversity
      if perturb and card(K) > 2 then
        setrandseed(seed)
        num_remove := ceil(random * minlist(3, card(K) / 2))

        ! Remove random facilities
        fac_array := []
        forall(i in K)
          fac_array += [i]

        forall(i in 1..num_remove) do
          if card(K) > 0 then
            idx := ceil(random * card(K))
            if idx >= 1 and idx <= getsize(fac_array) then
              rem_fac := fac_array(idx)
              if rem_fac in K then
                K -= {rem_fac}
                budget_used -= COST(rem_fac)
              end-if
            end-if
          end-if
        end-do

        ! Try to add random different facilities
        cand_array := []
        forall(i in FACILITIES | i not in K)
          cand_array += [i]

        forall(i in 1..num_remove) do
          if getsize(cand_array) > 0 then
            idx := ceil(random * getsize(cand_array))
            if idx >= 1 and idx <= getsize(cand_array) then
              add_fac := cand_array(idx)
              if budget_used + COST(add_fac) <= BUDGET then
                K += {add_fac}
                budget_used += COST(add_fac)
              end-if
            end-if
          end-if
        end-do
      end-if

    elif use_cn then
      ! Closest Neighbor initialization
      ! Sort customers by demand
      cust_array := []
      demand_array := []
      forall(j in CUSTOMERS) do
        cust_array += [j]
        demand_array += [DEMAND(j)]
      end-do

      ! Simple bubble sort (descending)
      forall(i in 1..nJ-1) do
        forall(j in i+1..nJ) do
          if demand_array(i) < demand_array(j) then
            temp_d := demand_array(i)
            demand_array(i) := demand_array(j)
            demand_array(j) := temp_d

            temp_c := cust_array(i)
            cust_array(i) := cust_array(j)
            cust_array(j) := temp_c
          end-if
        end-do
      end-do

      covered := {}

      ! Process customers
      forall(idx in 1..nJ) do
        customer := cust_array(idx)

        if customer in covered or budget_used >= BUDGET then
          next
        end-if

        ! Find closest facility
        best_fac := -1
        best_cost := infinity

        forall(i in I_j(customer)) do
          if i not in K and budget_used + COST(i) <= BUDGET then
            if COST(i) < best_cost then
              best_cost := COST(i)
              best_fac := i
            end-if
          end-if
        end-do

        if best_fac <> -1 then
          K += {best_fac}
          covered += J_i(best_fac)
          budget_used += COST(best_fac)
        end-if
      end-do

    elif use_random then
      ! Random initialization
      setrandseed(seed)
      fac_array := []
      forall(i in FACILITIES)
        fac_array += [i]

      ! Shuffle
      forall(i in 1..nI) do
        j := ceil(random * (nI - i + 1)) + i - 1
        if j >= i and j <= nI then
          temp := fac_array(i)
          fac_array(i) := fac_array(j)
          fac_array(j) := temp
        end-if
      end-do

      forall(i in 1..nI) do
        fac := fac_array(i)
        if budget_used + COST(fac) <= BUDGET then
          K += {fac}
          budget_used += COST(fac)
        end-if
      end-do
    end-if

    ! Initialize coverage tracking
    forall(j in CUSTOMERS)
      covered_by_count(j) := 0

    forall(i in K) do
      forall(j in J_i(i))
        covered_by_count(j) += 1
    end-do

    ! Compute initial objective
    objective := 0.0
    forall(j in CUSTOMERS) do
      if covered_by_count(j) > 0 then
        objective += DEMAND(j)
      end-if
    end-do

    initial_obj := objective

    if VERBOSE >= 2 then
      writeln("  Initial: obj=", strfmt(initial_obj, 10, 2),
              ", facilities=", card(K))
    end-if

    ! ================================================
    ! LOCAL SEARCH
    ! ================================================

    iteration := 0
    improvements := 0

    while iteration < MAX_MOVES do
      iteration += 1

      ! Find best improving move (first-improvement)
      best_delta := 0.0
      best_move := ""
      best_i := -1
      best_j := -1
      found := false

      ! Try close moves
      forall(i in K) do
        loss := 0.0
        forall(j in J_i(i)) do
          if covered_by_count(j) = 1 then
            loss += DEMAND(j)
          end-if
        end-do
        delta := -loss

        if delta > best_delta then
          best_delta := delta
          best_move := "close"
          best_i := i
          found := true
          break
        end-if
      end-do

      ! Try open moves
      if not found then
        forall(i in FACILITIES | i not in K) do
          if budget_used + COST(i) > BUDGET then
            next
          end-if

          gain := 0.0
          forall(j in J_i(i)) do
            if covered_by_count(j) = 0 then
              gain += DEMAND(j)
            end-if
          end-do

          if gain > best_delta then
            best_delta := gain
            best_move := "open"
            best_i := i
            found := true
            break
          end-if
        end-do
      end-if

      ! Try swap moves
      if not found then
        forall(i_out in K) do
          forall(j_in in FACILITIES | j_in not in K) do
            if budget_used - COST(i_out) + COST(j_in) > BUDGET then
              next
            end-if

            loss := 0.0
            forall(j in J_i(i_out)) do
              if covered_by_count(j) = 1 then
                loss += DEMAND(j)
              end-if
            end-do

            gain := 0.0
            forall(j in J_i(j_in)) do
              if covered_by_count(j) = 0 or
                 (covered_by_count(j) = 1 and i_out in I_j(j)) then
                gain += DEMAND(j)
              end-if
            end-do

            delta := gain - loss

            if delta > best_delta then
              best_delta := delta
              best_move := "swap"
              best_i := i_out
              best_j := j_in
              found := true
              break
            end-if
          end-do

          if found then
            break
          end-if
        end-do
      end-if

      ! If no improving move, terminate
      if not found or best_delta <= 1e-6 then
        break
      end-if

      ! Apply move
      if best_move = "close" then
        K -= {best_i}
        budget_used -= COST(best_i)
        forall(j in J_i(best_i)) do
          covered_by_count(j) -= 1
          if covered_by_count(j) = 0 then
            objective -= DEMAND(j)
          end-if
        end-do
        improvements += 1

      elif best_move = "open" then
        K += {best_i}
        budget_used += COST(best_i)
        forall(j in J_i(best_i)) do
          if covered_by_count(j) = 0 then
            objective += DEMAND(j)
          end-if
          covered_by_count(j) += 1
        end-do
        improvements += 1

      elif best_move = "swap" then
        ! Close i_out
        K -= {best_i}
        budget_used -= COST(best_i)
        forall(j in J_i(best_i)) do
          covered_by_count(j) -= 1
          if covered_by_count(j) = 0 then
            objective -= DEMAND(j)
          end-if
        end-do

        ! Open j_in
        K += {best_j}
        budget_used += COST(best_j)
        forall(j in J_i(best_j)) do
          if covered_by_count(j) = 0 then
            objective += DEMAND(j)
          end-if
          covered_by_count(j) += 1
        end-do
        improvements += 1
      end-if
    end-do

    final_obj := objective
    improvement := final_obj - initial_obj
    runtime := gettime - start_time

    ! Store results
    start_results(start_idx).start_idx := start_idx
    start_results(start_idx).method := init_method
    start_results(start_idx).initial_obj := initial_obj
    start_results(start_idx).final_obj := final_obj
    start_results(start_idx).improvement := improvement
    start_results(start_idx).num_moves := iteration
    start_results(start_idx).runtime := runtime

    if VERBOSE >= 1 then
      writeln("  Final:   obj=", strfmt(final_obj, 10, 2),
              ", improvement=", strfmt(improvement, 8, 2),
              ", moves=", improvements,
              ", time=", strfmt(runtime, 6, 3), "s")
    end-if

    ! Update global best
    if final_obj > global_best_obj then
      global_best_obj := final_obj
      global_best_K := K
      if VERBOSE >= 1 then
        writeln("  [*] New global best!")
      end-if
    end-if
  end-do

  overall_runtime := gettime - overall_start_time

  !==================================================
  ! OUTPUT RESULTS
  !==================================================

  if VERBOSE >= 1 then
    writeln("\n", "="*70)
    writeln("MULTI-START SUMMARY")
    writeln("="*70)

    ! Compute statistics
    avg_initial := sum(s in 1..N_STARTS) start_results(s).initial_obj / N_STARTS
    avg_final := sum(s in 1..N_STARTS) start_results(s).final_obj / N_STARTS
    avg_improvement := sum(s in 1..N_STARTS) start_results(s).improvement / N_STARTS

    writeln("Total starts: ", N_STARTS)
    writeln("Total runtime: ", strfmt(overall_runtime, 8, 2), " seconds")
    writeln("Avg initial objective: ", strfmt(avg_initial, 10, 2))
    writeln("Avg final objective: ", strfmt(avg_final, 10, 2))
    writeln("Avg improvement: ", strfmt(avg_improvement, 10, 2))
    writeln("\nBest solution found:")
    writeln("  Objective: ", strfmt(global_best_obj, 10, 2),
            " / ", strfmt(total_demand, 10, 2),
            " (", strfmt(global_best_obj/total_demand*100, 5, 1), "%)")
    writeln("  Open facilities: ", card(global_best_K), " / ", nI)
    writeln("  Budget used: ", strfmt(sum(i in global_best_K) COST(i), 10, 2),
            " / ", BUDGET)

    writeln("\nOPEN FACILITIES:")
    write(" ")
    forall(i in global_best_K)
      write(" ", i)
    writeln("")
  end-if

  writeln("\n", "="*70)

end-model
