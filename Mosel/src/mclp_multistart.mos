(!******************************************************
   Maximum Covering Location Problem (MCLP)
   Multi-Start Local Search

   Algorithm: Run local search from multiple diverse
   initial solutions and track the global best.

   Initialization Strategies:
   1. Deterministic Greedy
   2. Deterministic Closest Neighbor
   3. Perturbed Greedy (randomized)
   4. Random solutions

   Time Complexity: O(n_starts · max_moves · nI · nJ)
   Space Complexity: O(nI + nJ)

   Reference: Multi-start metaheuristic framework

   Author: Syed Abbas Ahmad
   Date: November 2025
   Phase: 4 - Multi-Start Local Search
******************************************************!)

model "MCLP_Multi_Start"
  uses "mmsystem"

  !==================================================
  ! PARAMETERS
  !==================================================

  parameters
    DATA_FILE = "data/test_tiny.dat"  ! Default instance
    N_STARTS = 10                      ! Number of starts
    MAX_MOVES = 200                    ! LS iterations per start
    BASE_SEED = 42                     ! Base random seed
  end-parameters

  !==================================================
  ! FORWARD DECLARATIONS
  !==================================================

  declarations
    nI, nJ: integer
    BUDGET: real
  end-declarations

  !==================================================
  ! LOAD INSTANCE DIMENSIONS
  !==================================================

  initializations from DATA_FILE
    nI nJ BUDGET
  end-initializations

  declarations
    ! Additional variables
    overall_start_time: real
    seed: integer
    init_method: string
    use_greedy: boolean
    use_cn: boolean
    use_random: boolean
    perturb: boolean
    covered: set of integer
    best_fac: integer
    best_ratio: real
    customer: integer
    best_cost: real
    total_demand: real
    overall_runtime: real
    avg_initial: real
    avg_final: real
    avg_improvement: real
    K: set of integer
    covered_by_count: array(0..nJ-1) of integer
    budget_used: real
    objective: real
    fac_array: array(range) of integer
    cand_array: array(range) of integer
    cust_array: array(range) of integer
    demand_array: array(range) of real
    num_remove: integer
    idx: integer
    rem_fac: integer
    add_fac: integer
    temp_d: real
    temp_c: integer
    temp: integer
    fac: integer
    swap_idx: integer
    delta: real
    loss: real
    gain: real
    best_delta: real
    best_move: string
    best_i: integer
    best_j: integer
    found: boolean
    iteration: integer
    improvements: integer
    initial_obj: real
    final_obj: real
    improvement: real
    runtime: real
    start_time: real
    new_cust: set of integer
    ratio: real
  end-declarations

  writeln("\n", "======================================================================")
  writeln("MCLP MULTI-START LOCAL SEARCH")
  writeln("======================================================================")
  writeln("Instance: ", DATA_FILE)
  writeln("Facilities: ", nI, ", Customers: ", nJ)
  writeln("Budget: ", BUDGET)
  writeln("Number of starts: ", N_STARTS)
  writeln("======================================================================", "\n")

  !==================================================
  ! MAIN DECLARATIONS
  !==================================================

  declarations
    FACILITIES: set of integer
    CUSTOMERS: set of integer
    COST: array(0..nI-1) of real
    DEMAND: array(0..nJ-1) of real
    I_j: array(0..nJ-1) of set of integer
    J_i: array(0..nI-1) of set of integer
  end-declarations

  !==================================================
  ! LOAD INSTANCE DATA
  !==================================================

  initializations from DATA_FILE
    FACILITIES CUSTOMERS
    COST DEMAND
    I_j as "COVERAGE_I_j"
    J_i as "COVERAGE_J_i"
  end-initializations

  total_demand := sum(j in CUSTOMERS) DEMAND(j)

  !==================================================
  ! MULTI-START TRACKING
  !==================================================

  declarations
    global_best_K: set of integer
    global_best_obj: real
    start_results: array(1..N_STARTS) of record
      start_idx: integer
      method: string
      initial_obj: real
      final_obj: real
      improvement: real
      num_moves: integer
      runtime: real
    end-record
  end-declarations

  global_best_K := {}
  global_best_obj := -MAX_REAL

  overall_start_time := gettime

  !==================================================
  ! MULTI-START LOOP
  !==================================================

  forall(start_idx in 1..N_STARTS) do
    seed := BASE_SEED + start_idx

    ! Determine initialization method
    if start_idx = 1 then
      init_method := "Greedy"
      use_greedy := true
      use_cn := false
      use_random := false
      perturb := false
    elif start_idx = 2 then
      init_method := "Closest-Neighbor"
      use_greedy := false
      use_cn := true
      use_random := false
      perturb := false
    elif start_idx <= (N_STARTS + 2) / 2 then
      init_method := "Perturbed-Greedy"
      use_greedy := true
      use_cn := false
      use_random := false
      perturb := true
    else
      init_method := "Random"
      use_greedy := false
      use_cn := false
      use_random := true
      perturb := false
    end-if

    writeln("\n", "----------------------------------------------------------------------")
    writeln("Start ", start_idx, " / ", N_STARTS, " (", init_method, ")")
    writeln("----------------------------------------------------------------------")

    start_time := gettime

    ! ================================================
    ! INITIALIZATION
    ! ================================================

    K := {}
    budget_used := 0.0

    ! Initialize based on method
    if use_greedy then
      ! Greedy initialization
      covered := {}

      while (budget_used < BUDGET) do
        best_fac := -1
        best_ratio := 0.0

        forall(i in FACILITIES) do
          if i in K or budget_used + COST(i) > BUDGET then
            next
          end-if

          new_cust := J_i(i) - covered
          gain := sum(j in new_cust) DEMAND(j)
          ratio := if(COST(i) > 0, gain / COST(i), 999999)

          if ratio > best_ratio then
            best_ratio := ratio
            best_fac := i
          end-if
        end-do

        if best_fac = -1 or best_ratio <= 0 then
          break
        end-if

        K += {best_fac}
        covered += J_i(best_fac)
        budget_used += COST(best_fac)

        if perturb then
            ! Perturbation logic
            num_remove := ceil(getsize(K) * 0.3)
            
            ! Remove random facilities
            delcell(fac_array)
            idx := 1
            forall(i in K) do
                fac_array(idx) := i
                idx += 1
            end-do
            
            forall(i in 1..num_remove) do
                if getsize(K) > 0 then
                    idx := ceil(random * getsize(K))
                    if idx >= 1 and idx <= getsize(fac_array) then
                        rem_fac := fac_array(idx)
                        if rem_fac in K then
                            K -= {rem_fac}
                            budget_used -= COST(rem_fac)
                        end-if
                    end-if
                end-if
            end-do
            
            ! Add random different facilities
            delcell(cand_array)
            idx := 1
            forall(i in FACILITIES | i not in K) do
                cand_array(idx) := i
                idx += 1
            end-do
            
            forall(i in 1..num_remove) do
                if getsize(cand_array) > 0 then
                    idx := ceil(random * getsize(cand_array))
                    if idx >= 1 and idx <= getsize(cand_array) then
                        add_fac := cand_array(idx)
                        if budget_used + COST(add_fac) <= BUDGET then
                            K += {add_fac}
                            budget_used += COST(add_fac)
                        end-if
                    end-if
                end-if
            end-do
        end-if
      end-do

    elif use_cn then
      ! Closest Neighbor initialization
      ! Sort customers by demand
      delcell(cust_array)
      delcell(demand_array)
      idx := 1
      forall(j in CUSTOMERS) do
        cust_array(idx) := j
        demand_array(idx) := DEMAND(j)
        idx += 1
      end-do

      ! Simple bubble sort (descending)
      forall(i in 1..nJ-1) do
        forall(j in i+1..nJ) do
          if demand_array(i) < demand_array(j) then
            temp_d := demand_array(i)
            demand_array(i) := demand_array(j)
            demand_array(j) := temp_d

            temp_c := cust_array(i)
            cust_array(i) := cust_array(j)
            cust_array(j) := temp_c
          end-if
        end-do
      end-do

      covered := {}

      ! Process customers
      forall(cust_idx in 1..nJ) do
        customer := cust_array(cust_idx)

        if customer in covered or budget_used >= BUDGET then
          next
        end-if

        ! Find closest facility
        best_fac := -1
        best_cost := MAX_REAL

        forall(i in I_j(customer)) do
          if i not in K and budget_used + COST(i) <= BUDGET then
            if COST(i) < best_cost then
              best_cost := COST(i)
              best_fac := i
            end-if
          end-if
        end-do

        if best_fac <> -1 then
          K += {best_fac}
          covered += J_i(best_fac)
          budget_used += COST(best_fac)
        end-if
      end-do

    elif use_random then
      ! Random initialization
      setrandseed(seed)
      delcell(fac_array)
      idx := 1
      forall(i in FACILITIES) do
        fac_array(idx) := i
        idx += 1
      end-do

      ! Shuffle
      forall(i in 1..nI) do
        swap_idx := ceil(random * (nI - i + 1)) + i - 1
        if swap_idx >= i and swap_idx <= nI then
          temp := fac_array(i)
          fac_array(i) := fac_array(swap_idx)
          fac_array(swap_idx) := temp
        end-if
      end-do

      forall(i in 1..nI) do
        fac := fac_array(i)
        if budget_used + COST(fac) <= BUDGET then
          K += {fac}
          budget_used += COST(fac)
        end-if
      end-do
    end-if

    ! Initialize coverage tracking
    forall(j in CUSTOMERS) do
      covered_by_count(j) := 0
    end-do

    forall(i in K) do
      forall(j in J_i(i)) do
        covered_by_count(j) += 1
      end-do
    end-do

    ! Compute initial objective
    objective := 0.0
    forall(j in CUSTOMERS) do
      if covered_by_count(j) > 0 then
        objective += DEMAND(j)
      end-if
    end-do

    initial_obj := objective


    ! ================================================
    ! LOCAL SEARCH
    ! ================================================

    iteration := 0
    improvements := 0

    while (iteration < MAX_MOVES) do
      iteration += 1

      ! Find best improving move (first-improvement)
      best_delta := 0.0
      best_move := ""
      best_i := -1
      best_j := -1
      found := false

      ! Try close moves
      forall(i in K) do
        loss := 0.0
        forall(j in J_i(i)) do
          if covered_by_count(j) = 1 then
            loss += DEMAND(j)
          end-if
        end-do
        delta := -loss

        if delta > best_delta then
          best_delta := delta
          best_move := "close"
          best_i := i
          found := true
          break
        end-if
      end-do

      ! Try open moves
      if not found then
        forall(i in FACILITIES | i not in K) do
          if budget_used + COST(i) > BUDGET then
            next
          end-if

          gain := 0.0
          forall(j in J_i(i)) do
            if covered_by_count(j) = 0 then
              gain += DEMAND(j)
            end-if
          end-do

          if gain > best_delta then
            best_delta := gain
            best_move := "open"
            best_i := i
            found := true
            break
          end-if
        end-do
      end-if

      ! Try swap moves
      if not found then
        forall(i_out in K) do
          forall(j_in in FACILITIES | j_in not in K) do
            if budget_used - COST(i_out) + COST(j_in) > BUDGET then
              next
            end-if

            loss := 0.0
            forall(j in J_i(i_out)) do
              if covered_by_count(j) = 1 then
                loss += DEMAND(j)
              end-if
            end-do

            gain := 0.0
            forall(j in J_i(j_in)) do
              if covered_by_count(j) = 0 or
                 (covered_by_count(j) = 1 and i_out in I_j(j)) then
                gain += DEMAND(j)
              end-if
            end-do

            delta := gain - loss

            if delta > best_delta then
              best_delta := delta
              best_move := "swap"
              best_i := i_out
              best_j := j_in
              found := true
              break
            end-if
          end-do

          if found then
            break
          end-if
        end-do
      end-if

      ! If no improving move, terminate
      if not found or best_delta <= 1e-6 then
        break
      end-if

      ! Apply move
      if best_move = "close" then
        K -= {best_i}
        budget_used -= COST(best_i)
        forall(j in J_i(best_i)) do
          covered_by_count(j) -= 1
          if covered_by_count(j) = 0 then
            objective -= DEMAND(j)
          end-if
        end-do
        improvements += 1

      elif best_move = "open" then
        K += {best_i}
        budget_used += COST(best_i)
        forall(j in J_i(best_i)) do
          if covered_by_count(j) = 0 then
            objective += DEMAND(j)
          end-if
          covered_by_count(j) += 1
        end-do
        improvements += 1

      elif best_move = "swap" then
        ! Close i_out
        K -= {best_i}
        budget_used -= COST(best_i)
        forall(j in J_i(best_i)) do
          covered_by_count(j) -= 1
          if covered_by_count(j) = 0 then
            objective -= DEMAND(j)
          end-if
        end-do

        ! Open j_in
        K += {best_j}
        budget_used += COST(best_j)
        forall(j in J_i(best_j)) do
          if covered_by_count(j) = 0 then
            objective += DEMAND(j)
          end-if
          covered_by_count(j) += 1
        end-do
        improvements += 1
      end-if
    end-do

    final_obj := objective
    improvement := final_obj - initial_obj
    runtime := gettime - start_time

    ! Store results
    start_results(start_idx).start_idx := start_idx
    start_results(start_idx).method := init_method
    start_results(start_idx).initial_obj := initial_obj
    start_results(start_idx).final_obj := final_obj
    start_results(start_idx).improvement := improvement
    start_results(start_idx).num_moves := improvements
    start_results(start_idx).runtime := runtime

    ! Update global best
    if final_obj > global_best_obj then
      global_best_obj := final_obj
      global_best_K := K
    end-if

    writeln("  Final: obj=", strfmt(final_obj, 10, 2),
            ", impr=", strfmt(improvement, 10, 2),
            ", moves=", improvements,
            ", time=", strfmt(runtime, 6, 2), "s")
  end-do

  overall_runtime := gettime - overall_start_time

  !==================================================
  ! OUTPUT RESULTS
  !==================================================

  writeln("\n", "======================================================================")
  writeln("MULTI-START SUMMARY")
  writeln("======================================================================")

  ! Compute statistics
  avg_initial := sum(s in 1..N_STARTS) start_results(s).initial_obj / N_STARTS
  avg_final := sum(s in 1..N_STARTS) start_results(s).final_obj / N_STARTS
  avg_improvement := sum(s in 1..N_STARTS) start_results(s).improvement / N_STARTS

  writeln("Total starts: ", N_STARTS)
  writeln("Total runtime: ", strfmt(overall_runtime, 8, 2), " seconds")
  writeln("Avg initial objective: ", strfmt(avg_initial, 10, 2))
  writeln("Avg final objective: ", strfmt(avg_final, 10, 2))
  writeln("Avg improvement: ", strfmt(avg_improvement, 10, 2))
  writeln("\nBest solution found:")
  writeln("  Objective: ", strfmt(global_best_obj, 10, 2),
          " / ", strfmt(total_demand, 10, 2),
          " (", strfmt(global_best_obj/total_demand*100, 5, 1), "%)")
  writeln("  Open facilities: ", getsize(global_best_K), " / ", nI)
  writeln("  Budget used: ", strfmt(sum(i in global_best_K) COST(i), 10, 2),
          " / ", BUDGET)

  writeln("\nOPEN FACILITIES:")
  write(" ")
  forall(i in global_best_K) do
    write(" ", i)
  end-do
  writeln("")

  writeln("\n", "======================================================================")

end-model
