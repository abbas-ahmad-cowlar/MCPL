================================================================================
CLOSEST NEIGHBOR HEURISTIC FOR MCLP
================================================================================

Algorithm Name: Closest Neighbor with Demand Prioritization
Type: Constructive Heuristic
Complexity: O(nJ · nI · log(nI)) time, O(nI + nJ) space

================================================================================
ALGORITHM DESCRIPTION
================================================================================

The Closest Neighbor heuristic prioritizes customers by demand (high to low)
and selects the nearest (cheapest) feasible facility to cover each customer.
This distance-based approach focuses on satisfying high-value customers first,
using facility cost as a proxy for distance when no explicit distance data
is available.

Key Features:
- Demand-driven customer prioritization
- Distance-based facility selection (cost as proxy)
- Customer-centric (focuses on serving valuable customers)
- Sequential facility opening based on customer needs

================================================================================
PSEUDOCODE
================================================================================

ALGORITHM Closest-Neighbor-MCLP(I, J, f, d, I_j, J_i, B)
  INPUT:
    I           - Set of facilities
    J           - Set of customers
    f[i]        - Cost of opening facility i ∈ I (used as distance proxy)
    d[j]        - Demand of customer j ∈ J
    I_j[j]      - Set of facilities that can cover customer j
    J_i[i]      - Set of customers covered by facility i
    B           - Total budget available

  OUTPUT:
    K           - Set of open facilities
    objective   - Total covered demand
    covered     - Set of covered customers

  BEGIN
    // Initialize solution
    K ← ∅                          // Open facilities
    covered ← ∅                    // Covered customers
    budget_used ← 0.0              // Current budget used

    // Step 1: Sort customers by demand (descending)
    customers_sorted ← SORT(J, by=d[j], order=DESCENDING)

    PRINT "Sorted customers by demand (highest first)"

    // Step 2: Process customers in demand order
    FOR EACH j ∈ customers_sorted DO
      // Skip if already covered or budget exhausted
      IF j ∈ covered OR budget_used ≥ B THEN
        CONTINUE
      END IF

      // Find closest (cheapest) feasible facility for customer j
      best_facility ← null
      best_distance ← ∞

      FOR EACH i ∈ I_j[j] DO  // Only consider facilities that can cover j
        // Skip if already open
        IF i ∈ K THEN
          CONTINUE
        END IF

        // Check budget feasibility
        IF budget_used + f[i] > B THEN
          CONTINUE
        END IF

        // Use facility cost as distance proxy
        distance ← f[i]

        // Tie-breaking: prefer lower distance (cost), then lower facility ID
        IF distance < best_distance OR
           (distance = best_distance AND
            (best_facility = null OR i < best_facility)) THEN
          best_distance ← distance
          best_facility ← i
        END IF
      END FOR

      // If feasible facility found, open it
      IF best_facility ≠ null THEN
        K ← K ∪ {best_facility}
        covered ← covered ∪ J_i[best_facility]
        budget_used ← budget_used + f[best_facility]

        PRINT "Customer", j, "(demand=", d[j], "): Opened facility",
              best_facility, "(cost=", f[best_facility], ")"
      ELSE
        PRINT "Customer", j, "(demand=", d[j], "): No feasible facility"
      END IF
    END FOR

    // Compute final objective value
    objective ← Σ{d[j] : j ∈ covered}

    RETURN K, objective, covered
  END

================================================================================
EXAMPLE EXECUTION
================================================================================

Instance: test_tiny
- Facilities: 4 (costs: [2.0, 3.0, 2.5, 1.5])
- Customers: 8 (demands: [10, 15, 20, 25, 30, 12, 18, 22])
- Budget: 5.0

Step 1: Sort customers by demand
  Sorted order: [4(30), 3(25), 7(22), 2(20), 6(18), 1(15), 5(12), 0(10)]

Step 2: Process customers sequentially

Customer 4 (demand=30):
  Can be covered by: I_j[4] = {1, 3}
  Facility 1 cost: 3.0
  Facility 3 cost: 1.5 ✓ CLOSEST (cheapest)
  → Open facility 3, budget_used = 1.5
  → Now covered: {3, 4, 5, 7}

Customer 3 (demand=25):
  Already covered by facility 3 → SKIP

Customer 7 (demand=22):
  Already covered by facility 3 → SKIP

Customer 2 (demand=20):
  Can be covered by: I_j[2] = {2}
  Facility 2 cost: 2.5 ✓ ONLY OPTION
  Budget check: 1.5 + 2.5 = 4.0 ≤ 5.0 ✓ FEASIBLE
  → Open facility 2, budget_used = 4.0
  → Now covered: {1, 2, 3, 4, 5, 6, 7}

Customer 6 (demand=18):
  Already covered by facility 2 → SKIP

Customer 1 (demand=15):
  Already covered by facility 2 → SKIP

Customer 5 (demand=12):
  Already covered by facility 3 → SKIP

Customer 0 (demand=10):
  Can be covered by: I_j[0] = {0, 1}
  Facility 0 cost: 2.0
  Facility 1 cost: 3.0
  Facility 0 is closer but: 4.0 + 2.0 = 6.0 > 5.0 → INFEASIBLE
  Facility 1: 4.0 + 3.0 = 7.0 > 5.0 → INFEASIBLE
  → No feasible facility, customer 0 remains UNCOVERED

Final Solution:
  K = {2, 3}
  covered = {1, 2, 3, 4, 5, 6, 7}
  objective = 15 + 20 + 25 + 30 + 12 + 18 + 22 = 142

================================================================================
CORRECTNESS PROPERTIES
================================================================================

1. Budget Feasibility: Always maintains budget_used ≤ B
2. Coverage Validity: All covered customers have at least one open facility
3. Demand Priority: Processes high-demand customers first
4. Distance Optimization: Selects nearest facility for each customer
5. Termination: Guaranteed to terminate (all customers processed)

================================================================================
COMPLEXITY ANALYSIS
================================================================================

Time Complexity: O(nJ · nI · log(nI))
  - Sorting customers: O(nJ · log(nJ))
  - Main loop: O(nJ) iterations
  - Per iteration:
    * Find closest facility: O(|I_j[j]|) ≈ O(nI) on average
  - Total: O(nJ · log(nJ) + nJ · nI) = O(nJ · nI · log(nI))

Space Complexity: O(nI + nJ)
  - Sorted customer list: O(nJ)
  - Open facilities: O(nI)
  - Covered customers: O(nJ)

Practical Performance:
  - Small instances (50 facilities, 200 customers): < 0.1 seconds
  - Medium instances (100 facilities, 500 customers): < 1 second
  - Large instances (200 facilities, 1000 customers): < 3 seconds

Note: Slightly faster than Greedy due to single-pass processing

================================================================================
ADVANTAGES
================================================================================

1. Very fast execution (single pass through customers)
2. Customer-centric (prioritizes valuable customers)
3. Intuitive distance-based selection
4. Simple to implement
5. No parameters to tune
6. Good for instances with clear demand hierarchy

================================================================================
LIMITATIONS
================================================================================

1. Myopic: Only considers one customer at a time
2. May open multiple facilities when one would suffice
3. Cost as distance proxy may not reflect true distance
4. No consideration of facility's coverage potential
5. May leave budget unused
6. Solution quality sensitive to demand distribution

================================================================================
DISTANCE PROXY RATIONALE
================================================================================

Using Facility Cost as Distance:
- Assumption: More expensive facilities may serve larger/remote areas
- Justification: Cost correlates with facility size and service range
- Alternative: If explicit distances d_ij available, use min{d_ij : i ∈ I_j[j]}

True Distance Version (if distances available):
  FOR EACH i ∈ I_j[j] DO
    distance ← d_ij  // Actual Euclidean or network distance
    ...
  END FOR

================================================================================
COMPARISON WITH GREEDY
================================================================================

Closest Neighbor vs Greedy:

Similarities:
- Both are constructive heuristics
- Both run in polynomial time
- Both provide feasible solutions quickly

Differences:
| Aspect           | Closest Neighbor       | Greedy              |
|------------------|------------------------|---------------------|
| Selection basis  | Distance (cost proxy)  | Value per cost      |
| Customer order   | Sorted by demand       | Not explicitly      |
| Facility eval    | Per customer          | All facilities      |
| Iterations       | O(nJ)                 | O(nI)               |
| Runtime          | Faster                | Slightly slower     |
| Solution quality | Variable              | Generally better    |

Expected Performance Comparison (% of optimal):
- Small instances: CN: 75-90%, Greedy: 80-95%
- Medium instances: CN: 70-85%, Greedy: 75-90%
- Large instances: CN: 65-80%, Greedy: 70-85%

Greedy typically outperforms Closest Neighbor in solution quality,
but Closest Neighbor is faster and may perform better when:
- Demand is highly concentrated in few customers
- True distance data is available
- Budget is very tight

================================================================================
ENHANCEMENTS
================================================================================

Possible Improvements:
1. Use actual distance matrix if available (better than cost proxy)
2. Consider multiple facilities per customer (k-nearest neighbors)
3. Add post-processing: close expensive facilities, open cheaper ones
4. Hybrid: CN for initialization, then Greedy refinement
5. Two-phase: CN for high-demand customers, Greedy for remaining budget

================================================================================
TYPICAL USE CASES
================================================================================

Closest Neighbor is particularly effective when:
1. Customers have very different demand levels (high variance)
2. Budget is limited (must prioritize valuable customers)
3. Fast solution needed (real-time applications)
4. Serving high-demand customers is primary goal
5. True distance data is available (not just cost proxy)

================================================================================
REFERENCES
================================================================================

Distance-based greedy approaches appear in:
- Nearest neighbor algorithms for TSP and location problems
- Customer-centric facility location heuristics
- Priority-based covering strategies

Similar concepts:
- K-nearest neighbors for classification
- Closest facility queries in GIS
- Service allocation in logistics

================================================================================
